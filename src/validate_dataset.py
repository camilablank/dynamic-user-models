#!/usr/bin/env python3
"""
validate_dataset.py

Sanity-check a JSONL dataset generated by generate_dataset.py.
"""

import argparse, json, statistics as stats
from collections import Counter, defaultdict
import os

def load_jsonl(path: str):
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            yield json.loads(line)

def validate_sample(s):
    errs = []
    for k in ["id", "attribute_type", "messages", "user_state_per_turn", "style_controlled", "meta"]:
        if k not in s:
            errs.append(f"missing key: {k}")

    messages = s.get("messages", [])
    labels = s.get("user_state_per_turn", [])
    if len(messages) != 2 * len(labels):
        errs.append(f"messages length {len(messages)} != 2 * user_state_per_turn {len(labels)}")

    for i, m in enumerate(messages):
        want = "user" if i % 2 == 0 else "assistant"
        if m.get("role") != want:
            errs.append(f"messages[{i}].role={m.get('role')} expected={want}")
            break

    switch = s.get("switch_user_turn", None)
    if switch is not None:
        if not (0 <= switch < len(labels)):
            errs.append(f"switch_user_turn {switch} out of range [0, {len(labels)-1}]")
        else:
            pre = labels[max(0, switch - 1)] if switch - 1 >= 0 else labels[0]
            post = labels[switch]
            if pre == post and len(set(labels)) == 1:
                errs.append("switch present but all labels identical (no effective switch)")
    return errs

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--path", required=True, help="Path to JSONL dataset")
    ap.add_argument("--plot", action="store_true", help="Show histograms (requires matplotlib)")
    args = ap.parse_args()

    # Early file checks
    if not os.path.exists(args.path):
        print(f"❌ ERROR: File not found: {args.path}")
        return
    if os.path.getsize(args.path) == 0:
        print(f"⚠️ WARNING: File exists but is empty: {args.path}")
        return

    # Load first line to check for data
    try:
        with open(args.path, "r", encoding="utf-8") as f:
            first_line = f.readline().strip()
            if not first_line:
                print(f"⚠️ WARNING: No JSONL lines found in {args.path}")
                return
    except Exception as e:
        print(f"❌ ERROR reading file: {e}")
        return

    n = 0
    attr_counter = Counter()
    turn_counts = []
    switch_counts = Counter({"none": 0})
    switch_positions = Counter()
    style_true = 0
    errors_total = 0
    per_attr_turns = defaultdict(list)

    for s in load_jsonl(args.path):
        n += 1
        errs = validate_sample(s)
        errors_total += len(errs)

        attr = s.get("attribute_type", "UNKNOWN")
        attr_counter[attr] += 1

        labels = s.get("user_state_per_turn", [])
        t = len(labels)
        turn_counts.append(t)
        per_attr_turns[attr].append(t)

        sw = s.get("switch_user_turn", None)
        if sw is None:
            switch_counts["none"] += 1
        else:
            switch_positions[sw] += 1

        if s.get("style_controlled", False):
            style_true += 1

    if n == 0:
        print(f"⚠️ WARNING: No valid samples found in {args.path}")
        return

    # Print summary
    print(f"File: {args.path}")
    print(f"Samples: {n}")
    if errors_total > 0:
        print(f"Validation: ⚠️ {errors_total} structural issues found.")
    else:
        print("Validation: ✅ no structural issues found.")

    print("\nAttribute types:")
    for k, v in attr_counter.items():
        print(f"  - {k}: {v}")

    def describe(arr):
        if not arr:
            return "n=0"
        return f"n={len(arr)} | min={min(arr)} | max={max(arr)} | mean={sum(arr)/len(arr):.2f} | median={stats.median(arr):.2f}"

    print("\nUser turns per dialog:")
    print(f"  All: {describe(turn_counts)}")
    for a, arr in per_attr_turns.items():
        print(f"  {a}: {describe(arr)}")

    num_with_switch = n - switch_counts["none"]
    print("\nSwitch presence:")
    print(f"  with switch: {num_with_switch}")
    print(f"  without switch: {switch_counts['none']}")
    if num_with_switch > 0:
        print("  switch position counts:")
        for pos in sorted(switch_positions):
            print(f"    turn {pos}: {switch_positions[pos]}")

    frac_style = (style_true / n) if n else 0.0
    print(f"\nStyle-controlled fraction: {frac_style:.2%} ({style_true}/{n})")

    if args.plot:
        try:
            import matplotlib.pyplot as plt
            plt.figure()
            plt.hist(turn_counts, bins=range(min(turn_counts), max(turn_counts) + 2))
            plt.title("User turns per dialog")
            plt.xlabel("User turns"); plt.ylabel("Count")
            plt.show()

            if num_with_switch > 0:
                plt.figure()
                xs, ys = zip(*sorted(switch_positions.items()))
                plt.bar(xs, ys)
                plt.title("Switch positions")
                plt.xlabel("User turn index"); plt.ylabel("Count")
                plt.show()
        except ImportError:
            print("\n⚠️ matplotlib not installed, skipping plots.")

if __name__ == "__main__":
    main()
